
| **Category**               | **Similarity**                                                                 | **SimPy Syntax/Example**                              | **Simulus Syntax/Example**                           |
|----------------------------|-------------------------------------------------------------------------------|------------------------------------------------------|-----------------------------------------------------|
| **Process Definition**     | Both use Python generator functions to define simulation processes.           | `def process(env): yield env.timeout(1)`             | `def process(sim): yield sim.sleep(1)`              |
| **Discrete-Event Simulation** | Both are process-oriented, discrete-event simulation libraries in Python.      | `env = simpy.Environment(); env.run(until=10)`       | `sim = simulus.Simulator(); sim.run(until=10)`      |
| **Resource Modeling**      | Both provide resources for modeling queues or servers with limited capacity.   | `res = simpy.Resource(env, capacity=1)`              | `res = simulus.Resource(sim, capacity=1)`           |
| **Store for Queues**       | Both have a `Store` for modeling producer-consumer queues with capacity limits.| `store = simpy.Store(env, capacity=3)`               | `store = simulus.Store(sim, capacity=3)`            |
| **Quantity-Based Resources** | Both support resources for modeling levels (e.g., gas in a tank).            | `cont = simpy.Container(env, capacity=10, init=5)`   | `bucket = simulus.Bucket(sim, capacity=10, init=5)` |
| **Simulation Time Advance** | Both advance simulation time based on events or timeouts/sleeps.              | `yield env.timeout(1)`                               | `yield sim.sleep(1)`                                |
| **Process Creation**       | Both create processes within a simulation environment/simulator.              | `env.process(process(env))`                          | `sim.process(process(sim))`                         |
| **Producer-Consumer Pattern** | Both support producer-consumer models using stores or equivalent resources.   | `yield store.put(1); yield store.get()`              | `yield store.put(1); yield store.get()`             |



## Table 1: General Comparison

| **Feature**              | **SimPy**                              | **Simulus**                           |
|--------------------------|----------------------------------------|---------------------------------------|
| **Multi-process support** | Single-threaded event loop            | Supports multi-process and parallel simulation |
| **Real-time simulation**  | Supported, syncs with wall clock time | Planned for v1.3, not yet available   |
| **Inter-process communication** | Indirect, via shared resources        | Direct, via `Mailbox`                 |
| **Resources**            | `Resource`, `Container`, `Store`      | `Resource`, `Store`, `Bucket`, `Mailbox` |
| **Synchronization**      | Via shared resources and events       | Via resources, stores, buckets, mailboxes with conditional waits |

## Table 2: Detailed Feature Comparison

| **Aspect**               | **SimPy**                              | **Simulus**                           |
|--------------------------|----------------------------------------|---------------------------------------|
| **Process definition**   | Python generator functions            | Python generator functions            |
| **Simulation time**      | Managed by `Environment`, advances via `env.timeout(1)` | Managed by `Simulator`, advances via `sim.sleep(10)` |
| **Wall clock time sync** | Supported, documented in real-time guides | Planned for v1.3, currently unavailable |
| **Inter-process communication** | Indirect via `Store`, `Resource`, no direct messaging | Direct via `Mailbox` with `send()`, `recv()`, supports delays |
| **Synchronization**      | Implicit via resource availability (e.g., `request()`) | Explicit via `Resource` (trappable), `Store`/`Bucket`, `Mailbox` with conditional waits |





| **SimPy Limitation**                              | **Simulus Solution**                                                                 | **How Simulus Achieves It**                                                                                     | **Simulus Syntax/Example**                                   |
|--------------------------------------------------|-------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------|
| **Single-threaded execution**                    | Supports multi-process and parallel simulation, enabling distributed simulations.    | Uses a parallel simulation engine with MPI support, allowing multiple processes or simulators to run concurrently. | `sim = simulus.Simulator(); sim.process(process(sim))` in multiple simulators with MPI. |
| **No direct inter-process communication**        | Provides direct message passing via `Mailbox`.                                      | Implements `Mailbox` for sending/receiving messages with optional delays, enabling direct process interaction.    | `mbox = simulus.Mailbox(sim); mbox.send('msg', delay=1)`    |
| **Limited synchronization flexibility**           | Offers explicit synchronization with conditional waits and trappable resources.      | Uses `wait()` for conditional waits on resources, stores, buckets, and mailboxes, providing finer control.       | `yield sim.wait(mbox.receiver(), until=10)`                 |
| **Basic resource types**                         | Adds `Bucket` and `Mailbox` alongside `Resource` and `Store` for more flexibility.   | `Bucket` for uncountable quantities and `Mailbox` for message-based communication expand modeling capabilities.   | `bucket = simulus.Bucket(sim, capacity=10); mbox = simulus.Mailbox(sim)` |


Key Points

    It seems likely that replacing SimPy with Simulus is possible but may be complex, especially for large or real-time simulation models, due to differences in features and maturity.
    Research suggests Simulus offers advanced multi-process support and direct inter-process communication, while SimPy is more established with real-time simulation capabilities.
    The evidence leans toward migration requiring careful mapping of resources and potentially redesigning for parallel features, with challenges in learning curve and community support.

Overview

SimPy and Simulus are both discrete-event simulation libraries in Python, used for modeling systems like queues or production lines. Replacing SimPy with Simulus can be feasible, but it depends on your model's complexity and needs, such as real-time simulation or parallel processing. Below, we’ll explore their differences and the steps to migrate, keeping it simple for beginners.
Differences in Key Features

Both libraries use Python generator functions for processes, but they differ in how they handle multi-process support, resources, and communication:

    Multi-Process vs Single-Thread: SimPy runs in a single thread, while Simulus supports multi-process and parallel simulation, which is great for large-scale systems.
    Resources: Both have similar concepts like stores for queues, but Simulus adds mailboxes for direct messaging, which SimPy lacks.
    Inter-Process Communication: Simulus allows direct message passing, while SimPy relies on shared resources, which can be less flexible.
    Synchronization and Time: SimPy supports real-time simulation (syncing with wall clock time), but Simulus plans to add this in a future version (1.3). Both manage simulation time similarly, advancing based on events.

Migration Difficulty and Steps

Replacing SimPy with Simulus can be moderately challenging, especially if your model uses real-time features or is large. Here’s a simple guide:

    Analyze your SimPy model to identify resources and how processes interact.
    Map SimPy resources (like Resource or Store) to Simulus equivalents (e.g., Store to Store, Container to Bucket).
    Check if you need real-time simulation; if yes, note Simulus lacks this currently.
    Decide if you want to use Simulus’s parallel features, which may require redesigning.
    Rewrite your code using Simulus’s API and test to ensure it works as expected.

Given SimPy’s maturity, it might be easier to stick with it unless you need Simulus’s advanced features like parallel simulation.
Survey Note: Detailed Comparison of SimPy and Simulus

This section provides a comprehensive analysis of SimPy and Simulus, focusing on the requested aspects: multi-process vs single-thread differences, resources, inter-process communication, synchronization between queries in Simulus, simulation time vs wall clock time sync up in Simulus, and the difficulty of replacing existing SimPy code with Simulus, including the steps involved. The analysis is structured for clarity, with tables to highlight differences, and includes all relevant details from the research conducted on July 2, 2025.
Introduction to SimPy and Simulus

SimPy is a well-established, open-source discrete-event simulation library for Python, first released in December 2002 under the MIT License. It is widely used for modeling active components such as customers, vehicles, or agents, using Python generator functions. It supports shared resources like servers and stores, and is known for its real-time simulation capabilities, where simulation time can sync with wall clock time.

Simulus, developed by Jason Liu, is a newer discrete-event simulator in Python, with its GitHub repository indicating active development as of recent updates. It aims to be part of Python’s scientific computing ecosystem and offers advanced features like support for parallel and distributed simulation, planned for version 1.2, and real-time simulation in version 1.3. Its documentation highlights process-oriented simulation with constructs like mailboxes for direct inter-process communication.
Key Feature Comparison

The following tables summarize the differences based on the research, focusing on the user’s specified aspects.

Table 1: General Comparison of SimPy and Simulus
Feature	SimPy	Simulus
Multi-process support	No, single-threaded event loop	Yes, supports parallel and distributed simulation
Real-time simulation	Yes, supports syncing with wall clock time	Planned for v1.3, not yet available
Inter-process communication	Indirect, via shared resources	Direct, via Mailbox
Resources	Resource, Container, Store	Resource, Store, Bucket, Mailbox
Synchronization	Through shared resources and events	Through resources, stores, buckets, mailboxes, with conditional waits

Table 2: Specific Features Comparison
Aspect	SimPy	Simulus
Process definition	Python generator functions	Python generator functions
Simulation time	Managed by Environment, advances via timeouts (e.g., env.timeout(1))	Managed by Simulator, advances via sleeps (e.g., sim.sleep(10))
Wall clock time sync	Supported, documented in real-time simulation guides	Planned for v1.3, currently not available
Inter-process comm	No direct messaging, processes interact via resources like Store	Direct messaging with Mailbox, supports send(), recv(), etc., with delays
Synchronization	Wait for resources (e.g., request()), timeouts, implicit through shared resources	Explicit via Resource (trappable), Store/Bucket for producer-consumer, Mailbox for message-based sync, supports conditional waits
Detailed Analysis of Each Aspect

    Multi-Process vs Single-Thread Differences
        SimPy: Research indicates SimPy uses a single-threaded event loop, managing all processes within one thread. This is evident from its documentation, which describes processes as Python generators interacting via events in a single environment. It does not natively support multi-processing, though users could manually run multiple environments in separate processes, which is not built-in.
        Simulus: Simulus explicitly supports multi-process and parallel simulation, as noted in its GitHub repository and documentation. It allows processes to run as separate threads of control and supports distributed simulation using MPI, making it suitable for large-scale simulations on clusters. This is a significant advantage for models requiring parallel execution.
    Resources
        SimPy: Offers a range of shared resources, including:
            Resource: For modeling single-server or multi-server queues, limiting concurrent users.
            Container: For modeling levels, such as gas in a tank, with put() and get() for adding/removing quantities.
            Store: For modeling queues of items, with capacity limits, used in examples like bounded buffers.
        Simulus: Provides similar but expanded resources:
            Resource: Similar to SimPy, for server queues, with acquire() and release() methods, and can be used with Python’s with statement.
            Store: For countable objects, like SimPy’s Store, with put() and get(), used in producer-consumer examples.
            Bucket: For uncountable quantities, akin to SimPy’s Container, with capacity in integer/float.
            Mailbox: Unique to Simulus, for direct message passing, with methods like send(), recv(), peek(), and retrieve(), supporting delays.
        Both can model resources, but Simulus’s Mailbox adds direct communication, while SimPy focuses on indirect interaction.
    Inter-Process Communication
        SimPy: Processes communicate indirectly through shared resources. For example, a process waiting for a Resource will block until available, and Store allows passing items between processes, but there’s no direct message-passing mechanism. Examples like the bounded buffer use Store for producer-consumer, but it’s resource-based, not message-based.
        Simulus: Supports direct inter-process communication via Mailbox, which is explicitly designed for message passing. Examples include producer-consumer synchronization over bounded buffers using Mailbox, with features like specifying delays for messages. This makes Simulus more flexible for models requiring explicit communication, such as distributed systems.
    Synchronization Between Queries in Simulus
        SimPy: Synchronization is implicit, handled through shared resources. For instance, a process requesting a busy Resource will wait, and Store/Container operations block if capacity is reached. There’s no explicit mention of conditional waits beyond resource availability.
        Simulus: Offers explicit synchronization mechanisms:
            Resource: Trappable, allowing conditional waits via wait() function, ensuring mutual exclusion.
            Store and Bucket: Synchronize producers and consumers, blocking on capacity or availability, with examples like producer-consumer over bounded buffers.
            Mailbox: Synchronizes via message arrival, with receiver() supporting conditional waits, useful for models needing message-based synchronization.
        Simulus provides more granular control, especially with conditional waits, compared to SimPy’s implicit synchronization.
    Simulation Time vs Wall Clock Time Sync Up in Simulus
        SimPy: Supports real-time simulation, where simulation time can be synchronized with wall clock time. This is documented in its topical guides, allowing simulations to run at the same speed as real-world time, useful for live testing or demonstrations.
        Simulus: Currently, simulation time advances based on event timestamps or process sleep durations (e.g., sim.sleep(10)), but real-time simulation is planned for version 1.3, as noted in its GitHub repository. This means it does not yet support syncing with wall clock time, which could be a limitation for certain applications.

Migration Difficulty and Steps

Replacing existing SimPy code with Simulus involves several considerations, given their differences in maturity and features. The difficulty can range from moderate to high, depending on the model’s complexity and requirements.

    Challenges:
        API Differences: SimPy and Simulus have different APIs for resources and communication. For example, SimPy’s Store maps to Simulus’s Store, but Simulus’s Mailbox has no direct equivalent in SimPy, requiring redesign for communication patterns.
        Real-Time Simulation: If the SimPy model relies on real-time simulation, this is not yet available in Simulus (planned for v1.3), which could be a blocker.
        Learning Curve: Simulus’s support for parallel and distributed simulation (e.g., using MPI) may require additional learning, especially for users accustomed to SimPy’s single-threaded approach.
        Community and Documentation: SimPy has extensive documentation and a larger community, making it easier to find examples and support. Simulus, being newer, has fewer resources, which could complicate migration.
    Steps to Migrate:
        Analyze the SimPy Model: Identify all resources used (e.g., Resource, Store, Container), how processes interact, and whether real-time simulation is critical. Review the model’s structure, including any custom communication patterns.
        Map SimPy Resources to Simulus:
            SimPy Resource → Simulus Resource (both for server queues, with similar acquire()/release()).
            SimPy Store → Simulus Store (both for queues, with capacity limits, using put()/get()).
            SimPy Container → Simulus Bucket (both for levels, with capacity in quantities).
            For inter-process communication, if SimPy uses Store for passing items, consider Simulus’s Mailbox for direct messaging, which may require redesign.
        Handle Real-Time Simulation: If real-time is needed, note that Simulus lacks this feature currently. Consider delaying migration until version 1.3 or finding an alternative approach, such as running Simulus simulations faster and syncing manually.
        Decide on Parallel Features: If the model could benefit from parallel simulation, redesign it to use Simulus’s multi-process capabilities, potentially splitting the model into multiple simulators. If not, stick to a single-process model.
        Rewrite Process Definitions: Use Simulus’s API to define processes and resources, ensuring compatibility with the mapped resources. Test with simple examples first, like a bounded buffer, to verify behavior.
        Test and Validate: Run the migrated model and compare results with the original SimPy model. Adjust for any differences in behavior, such as synchronization or timing, and ensure performance meets expectations.

Example: Bounded Buffer Implementation

To illustrate, consider a bounded buffer (producer-consumer) example, which is common in both libraries:

    SimPy Example (from documentation):
    python

import simpy
import random

def producer(env, store):
    for i in range(5):
        yield env.timeout(random.expovariate(1))
        yield store.put(i)
        print(f"Produced {i}")

def consumer(env, store):
    while True:
        yield env.timeout(random.expovariate(1))
        item = yield store.get()
        print(f"Consumed {item}")

env = simpy.Environment()
store = simpy.Store(env, capacity=3)
env.process(producer(env, store))
env.process(consumer(env, store))
env.run(until=10)
Here, Store with capacity=3 models a bounded buffer, with producers adding items and consumers retrieving them, synchronized via the store.
Simulus Example (from documentation):
python

    import simulus
    import random

    def producer(sim, store):
        for i in range(5):
            yield sim.sleep(random.expovariate(1))
            yield store.put(i)
            print(f"Produced {i}")

    def consumer(sim, store):
        while True:
            yield sim.sleep(random.expovariate(1))
            item = yield store.get()
            print(f"Consumed {item}")

    sim = simulus.Simulator()
    store = simulus.Store(sim, capacity=3)
    sim.process(producer(sim, store))
    sim.process(consumer(sim, store))
    sim.run(until=10)
    Simulus uses a similar Store with capacity=3, but the API uses sim.sleep() instead of env.timeout(), and the simulator is simulus.Simulator().
    Key Difference: Both handle bounded buffers similarly, but Simulus’s API is slightly different, and it supports additional features like Mailbox for direct communication, which could be used for more complex interactions.

Conclusion

SimPy is a mature, well-documented library ideal for single-threaded, real-time simulations, with extensive community support. Simulus, while newer, offers advanced features like parallel and distributed simulation and direct inter-process communication via Mailbox, making it suitable for large-scale or distributed systems. Migration from SimPy to Simulus is possible but requires careful mapping of resources, handling of real-time needs, and potentially redesigning for parallel features. Given Simulus’s current limitations (e.g., lack of real-time simulation), it may be better suited for models where parallel processing is critical, while SimPy remains a safer choice for established, single-threaded models.






